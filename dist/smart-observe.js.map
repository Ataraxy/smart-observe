{"version":3,"file":"smart-observe.js","sources":["../src/dep.js","../src/constants.js","../src/util.js","../src/array.js","../src/observe.js","../src/expression.js","../node_modules/smart-next-tick/nextTick.js","../src/batcher.js","../src/watcher.js","../src/index.js"],"sourcesContent":["let uid = 0\n\n/**\n * A dep is an observable that can have multiple\n * watcher subscribing to it.\n */\n\nexport default class Dep {\n  // the current target watcher being evaluated.\n  // this is globally unique because there could be only one\n  // watcher being evaluated at any time.\n  static target = null\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  /**\n   * Add a subscriber.\n   *\n   * @param {Watcher} sub\n   */\n\n  addSub (sub) {\n    this.subs.push(sub)\n  }\n\n  /**\n   * Remove a subscriber.\n   *\n   * @param {Watcher} sub\n   */\n\n  removeSub (sub) {\n    this.subs.$remove(sub)\n  }\n\n  /**\n   * Add self as a dependency to the target watcher.\n   */\n\n  depend () {\n    Dep.target.addDep(this)\n  }\n\n  /**\n   * Notify all subscribers of a new value.\n   */\n\n  notify () {\n    const subs = this.subs\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n","export const OBSERVE_NAME = '__s_o__'\nexport const WATCHERS_PROPERTY_NAME = '__watchers__'\nexport const DATA_PROPTERTY_NAME = '__data__'\n\nexport const DEBUGGING = typeof process !== 'undefined'\n  && process.env.NODE_ENV !== 'production'\n","import {DEBUGGING} from './constants'\n\n/**\n * Define property with value.\n *\n * @param {Object} object\n * @param {String} property\n * @param {*} value\n * @param {Boolean} [enumerable]\n */\n\nexport function defineValue (object, property, value, enumerable) {\n  Object.defineProperty(object, property, {\n    value,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true,\n  })\n}\n\n/**\n * Define property with getter and setter.\n *\n * @param {Object} object\n * @param {String} property\n * @param {Function} getter\n * @param {Function} setter\n */\n\nexport function defineAccessor (object, property, getter, setter) {\n  Object.defineProperty(object, property, {\n    get: getter,\n    set: setter,\n    enumerable: true,\n    configurable: true,\n  })\n}\n\n/**\n * Array type check.\n *\n * @return {Boolean}\n */\n\nexport const isArray = Array.isArray\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} object\n * @return {Boolean}\n */\n\nconst toString = Object.prototype.toString\nconst OBJECT_STRING = '[object Object]'\nexport function isPlainObject (object) {\n  return toString.call(object) === OBJECT_STRING\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} object\n * @return {Boolean}\n */\n\nexport function isObject (object) {\n  return object !== null && typeof object === 'object'\n}\n\n/**\n * Function type check\n *\n * @param {*} func\n * @param {Boolean}\n */\n\nexport function isFunction (func) {\n  return typeof func === 'function'\n}\n\n/**\n * Iterate object\n *\n * @param {Object} object\n * @param {Function} callback\n */\n\nexport function everyEntries (object, callback) {\n  const keys = Object.keys(object)\n  for (let i = 0, l = keys.length; i < l; i++) {\n    callback(keys[i], object[keys[i]])\n  }\n}\n\n/**\n * noop is function which is nothing to do.\n */\n\nexport function noop () {}\n\n/**\n * @param {String} string\n */\n\nexport const warn = typeof DEBUGGING !== 'undefined' && DEBUGGING\n  && typeof console !== 'undefined' && console\n  && isFunction(console.warn)\n    ? console.warn\n    : noop\n\nexport let _Set\nif (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {\n  // use native Set when available.\n  _Set = Set\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = function () {\n    this.set = Object.create(null)\n  }\n  _Set.prototype.has = function (key) {\n    return this.set[key] !== undefined\n  }\n  _Set.prototype.add = function (key) {\n    this.set[key] = 1\n  }\n  _Set.prototype.clear = function () {\n    this.set = Object.create(null)\n  }\n}\n","import {defineValue} from './util'\nimport {OBSERVE_NAME} from './constants'\n\nconst arrayPrototype = Array.prototype\nconst arrayMethods = Object.create(arrayPrototype)\nconst arrayMutativeMethods = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse',\n]\n\n/**\n * Augment an target Array with arrayMethods\n *\n * @param {Array} array\n */\n\nexport default function amend (array) {\n  Object.setPrototypeOf(array, arrayMethods)\n}\n\n/**\n * Intercept mutating methods and emit events\n */\n\nfor (let i = 0, l = arrayMutativeMethods.length; i < l; i++) {\n  const method = arrayMutativeMethods[i]\n  // cache original method\n  const original = arrayPrototype[method]\n  defineValue(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const observer = this[OBSERVE_NAME]\n    let inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) observer.observeArray(inserted)\n    observer.dep.notify() // notify change\n    return result\n  })\n}\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} value\n * @return {*} - replaced element\n */\n\nfunction $set (index, value) {\n  if (index >= this.length) {\n    this.length = Number(index) + 1\n  }\n  return this.splice(index, 1, value)[0]\n}\ndefineValue(arrayPrototype, '$set', $set)\n\n/**\n * Convenience method to remove the element at given index\n * or target element reference.\n *\n * @param {*} item\n * @return {*} - removed element\n */\n\nfunction $remove (item) {\n  if (!this.length) return\n  const index = this.indexOf(item)\n  if (index > -1) {\n    return this.splice(index, 1)\n  }\n}\ndefineValue(arrayPrototype, '$remove', $remove)\n","import Dep from './dep'\nimport amendArray from './array'\nimport {\n  defineValue,\n  defineAccessor,\n  isArray,\n  isPlainObject,\n  everyEntries,\n} from './util'\nimport {OBSERVE_NAME} from './constants'\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @class\n * @param {Array|Object} value\n */\n\nclass Observer {\n  constructor (value) {\n    this.value = value\n    this.dep = new Dep()\n    defineValue(value, OBSERVE_NAME, this)\n    if (isArray(value)) {\n      amendArray(value)\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   *\n   * @param {Object} object\n   */\n\n  walk (object) {\n    everyEntries(object, (key, value) => this.convert(key, value))\n  }\n\n  /**\n   * Observe a list of Array items.\n   *\n   * @param {Array} items\n   */\n\n  observeArray (items) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n\n  /**\n   * Convert a property into getter/setter so we can emit\n   * the events when the property is accessed/changed.\n   *\n   * @param {String} key\n   * @param {*} value\n   */\n\n  convert (key, value) {\n    defineReactive(this.value, key, value)\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @return {Observer|undefined}\n */\n\nexport function observe (value) {\n  if (!value || typeof value !== 'object') return\n  let observer\n  if (\n    Object.prototype.hasOwnProperty.call(value, OBSERVE_NAME)\n    && value[OBSERVE_NAME] instanceof Observer\n  ) {\n    observer = value[OBSERVE_NAME]\n  } else if (\n    (isArray(value) || isPlainObject(value))\n    && Object.isExtensible(value)\n  ) {\n    observer = new Observer(value)\n  }\n  return observer\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} object\n * @param {String} key\n * @param {*} value\n */\n\nexport function defineReactive (object, key, value) {\n  const dep = new Dep()\n\n  const desc = Object.getOwnPropertyDescriptor(object, key)\n  if (desc && desc.configurable === false) return\n\n  // cater for pre-defined getter/setters\n  const getter = desc && desc.get\n  const setter = desc && desc.set\n\n  let childOb = observe(value)\n\n  function reactiveGetter () {\n    const currentValue = getter ? getter.call(object) : value\n    if (Dep.target) {\n      dep.depend()\n      if (childOb) {\n        childOb.dep.depend()\n      }\n      if (isArray(currentValue)) {\n        for (let i = 0, l = currentValue.length, e; i < l; i++) {\n          e = currentValue[i]\n          e && e[OBSERVE_NAME] && e[OBSERVE_NAME].dep.depend()\n        }\n      }\n    }\n    return currentValue\n  }\n  function reactiveSetter (newValue) {\n    const oldValue = getter ? getter.call(object) : value\n    if (newValue === oldValue) return\n    if (setter) {\n      setter.call(object, newValue)\n    } else {\n      value = newValue\n    }\n    childOb = observe(newValue)\n    dep.notify()\n  }\n  defineAccessor(object, key, reactiveGetter, reactiveSetter)\n}\n","import {warn} from './util'\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetterFunction (body) {\n  try {\n    /* eslint-disable no-new-func */\n    return new Function('scope', `return ${body};`)\n    /* eslint-enable no-new-func */\n  } catch (e) {\n    warn('Invalid expression. Generated function body: ' + body)\n  }\n}\n\n/**\n * Parse an expression to getter.\n *\n * @param {String} expression\n * @return {Function|undefined}\n */\n\nexport default function parse (expression) {\n  expression = String.prototype.trim.call(expression)\n  return makeGetterFunction('scope.' + expression)\n}\n","var callbacks = []\nvar pending = false\nfunction nextTickHandler () {\n    pending = false\n    var callbackCopies = callbacks.slice(0)\n    callbacks.length = 0\n    for (var i = 0; i < callbackCopies.length; i++) {\n        callbackCopies[i]()\n    }\n}\n\nvar callNextTick\nif (typeof process === 'object'\n    && process\n    && typeof process.nextTick === 'function'\n) {\n    callNextTick = process.nextTick\n} else if (typeof MutationObserver !== 'undefined') {\n    var counter = 0\n    var textNode = document.createTextNode(counter)\n    var observer = new MutationObserver(nextTickHandler)\n    observer.observe(textNode, {\n        characterData: true\n    })\n    callNextTick = function () {\n        counter = counter === 0 ? 1 : 0\n        textNode.data = String(counter)\n    }\n} else {\n    callNextTick = setTimeout\n}\n\n\nmodule.exports = function nextTick (callback, context) {\n    var func = callback\n    if (context) {\n        var args = []\n        var l = arguments.length\n        while (--l > 1) {\n            args.unshift(arguments[l])\n        }\n        func = function () {\n            callback.apply(context, args)\n        }\n    }\n    callbacks.push(func)\n    if (pending) {\n        return\n    }\n    pending = true\n    callNextTick(nextTickHandler)\n}\n","import nextTick from 'smart-next-tick'\n\nlet queue = []\nlet has = {}\nlet waiting = false\nlet queueIndex\n\n/**\n * Reset the batcher's state.\n */\n\nfunction resetBatcherState () {\n  queue = []\n  has = {}\n  waiting = false\n}\n\n/**\n * Flush queue and run the watchers.\n */\n\nfunction flushBatcherQueue () {\n  runBatcherQueue(queue)\n  resetBatcherState()\n}\n\n/**\n * Run the watchers in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction runBatcherQueue (queue) {\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (queueIndex = 0; queueIndex < queue.length; queueIndex++) {\n    const watcher = queue[queueIndex]\n    const id = watcher.id\n    has[id] = null\n    watcher.run()\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Watcher} watcher\n *   properties:\n *   - {Number} id\n *   - {Function} run\n */\n\nexport default function batch (watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = queue.length\n    queue.push(watcher)\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      nextTick(flushBatcherQueue)\n    }\n  }\n}\n","import observe from './index'\nimport Dep from './dep'\nimport parseExpression from './expression'\nimport batch from './batcher'\nimport {\n  isArray,\n  isObject,\n  isFunction,\n  _Set as Set,\n} from './util'\nimport {WATCHERS_PROPERTY_NAME} from './constants'\n\nlet uid = 0\n\nclass Watcher {\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   *\n   * @param {Object} owner\n   * @param {String|Function} getter\n   * @param {Function} callback\n   * @param {Object} options\n   *                 - {Boolean} deep\n   *                 - {Boolean} sync\n   *                 - {Boolean} lazy\n   * @constructor\n   */\n\n  constructor (owner, getter, callback, options) {\n    owner[WATCHERS_PROPERTY_NAME].push(this)\n    this.owner = owner\n    this.getter = getter\n    this.callback = callback\n    this.options = options\n    // uid for batching\n    this.id = ++uid\n    this.active = true\n    // for lazy watchers\n    this.dirty = options.lazy\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.value = options.lazy\n      ? undefined\n      : this.get()\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n\n  get () {\n    this.beforeGet()\n    const scope = this.owner\n    const value = this.getter.call(scope, scope)\n    if (this.options.deep) {\n      traverse(value)\n    }\n    this.afterGet()\n    return value\n  }\n\n  /**\n   * Prepare for dependency collection.\n   */\n\n  beforeGet () {\n    Dep.target = this\n  }\n\n  /**\n   * Add a dependency to this directive.\n   *\n   * @param {Dep} dep\n   */\n\n  addDep (dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n\n  afterGet () {\n    Dep.target = null\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n\n  /**\n   * Will be called when a dependency changes.\n   */\n\n  update () {\n    if (this.options.lazy) {\n      this.dirty = true\n    } else if (this.options.sync) {\n      this.run()\n    } else {\n      batch(this)\n    }\n  }\n\n  /**\n   * Will be called by the batcher.\n   */\n\n  run () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value\n        // Deep watchers and watchers on Object/Arrays should fire even when\n        // the value is the same, because the value may have mutated;\n        || ((isObject(value) || this.options.deep))\n      ) {\n        const oldValue = this.value\n        this.value = value\n        this.callback.call(this.owner, value, oldValue)\n      }\n    }\n  }\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n\n  evaluate () {\n    // avoid overwriting another watcher that is being collected.\n    const current = Dep.target\n    this.value = this.get()\n    this.dirty = false\n    Dep.target = current\n  }\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n\n  depend () {\n    let i = this.deps.length\n    while (i--) {\n      this.deps[i].depend()\n    }\n  }\n\n  /**\n   * Remove self from all dependencies' subcriber list.\n   */\n\n  teardown () {\n    if (this.active) {\n      let i = this.deps.length\n      while (i--) {\n        this.deps[i].removeSub(this)\n      }\n      this.active = false\n      this.owner = this.callback = this.value = null\n    }\n  }\n}\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {*} value\n */\n\nfunction traverse (value) {\n  let i, keys\n  if (isArray(value)) {\n    i = value.length\n    while (i--) traverse(value[i])\n  } else if (isObject(value)) {\n    keys = Object.keys(value)\n    i = keys.length\n    while (i--) traverse(value[keys[i]])\n  }\n}\n\n/**\n * Create an watcher instance, returns the new watcher.\n *\n * @param {Object} owner\n * @param {String|Function} expressionOrFunction\n * @param {Function} callback\n * @param {Object} options\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n * @return {Watcher}\n */\n\nexport function watch (owner, expressionOrFunction, callback, options) {\n  // parse expression for getter\n  const getter = isFunction(expressionOrFunction)\n               ? expressionOrFunction\n               : parseExpression(expressionOrFunction)\n  return new Watcher(owner, getter, callback, options)\n}\n\n/**\n * Make a computed getter, which can collect dependencies.\n *\n * @param {Object} owner\n * @param {Function} getter\n */\n\nexport function makeComputed (owner, getter) {\n  const watcher = new Watcher(owner, getter, null, {\n    deep: observe.deep,\n    lazy: true,\n    sync: observe.sync,\n  })\n  return function computedGetter () {\n    if (watcher.options.lazy && Dep.target && !Dep.target.options.lazy) {\n      watcher.options.lazy = false\n      watcher.callback = function () {\n        const deps = watcher.deps\n        for (let i = 0, l = deps.length; i < l; i++) {\n          deps[i].notify()\n        }\n      }\n    }\n    if (watcher.dirty) {\n      watcher.evaluate()\n    }\n    if (Dep.target) {\n      watcher.depend()\n    }\n    return watcher.value\n  }\n}\n","import {\n  observe as doObserve,\n  defineReactive,\n} from './observe'\nimport {\n  watch as doWatch,\n  makeComputed,\n} from './watcher'\nimport {\n  defineValue,\n  defineAccessor,\n  noop,\n  isFunction,\n  everyEntries,\n} from './util'\nimport {\n  WATCHERS_PROPERTY_NAME,\n  DATA_PROPTERTY_NAME,\n} from './constants'\n\nObject.defineProperties(observe, {\n  'react': {value: react},\n  'compute': {value: compute},\n  'watch': {value: watch},\n  'default': {value: watch, writable: true}, // Only could be react, compute or watch\n  'deep': {value: false, writable: true},\n  'lazy': {value: false, writable: true},\n  'sync': {value: false, writable: true},\n})\n\n/**\n * observe\n *\n * @public\n * @param {Object} target\n * @param {*} [expression]\n * @param {*} [func]\n * @param {*} [options]\n * @return {Function} observe\n */\n\nexport default function observe (target, expression, func, options) {\n  ensure(target)\n  return observe.default(target, expression, func, options)\n}\n\n/**\n * React options\n *\n * @param {Object} options\n * @param {Object} [target]\n * @return {Function} observe\n */\n\nfunction react (options, target) {\n  if (target) {\n    ensure(target)\n  } else {\n    target = {}\n    init(target)\n  }\n  options.methods && carryMethods(target, options.methods)\n  options.data && reactProperties(target, options.data)\n  options.computed && computeProperties(target, options.computed)\n  options.watchers && watchProperties(target, options.watchers)\n  return target\n}\n\n/**\n * Compute property\n *\n * @param {Object} target\n * @param {String} name\n * @param {Function|Object} getterOrAccessor\n *        - Function getter\n *        - Object accessor\n *          - Function [get]  - getter\n *          - Function [set]  - setter\n *          - Boolean [cache]\n * @param {Boolean} [cache]\n */\n\nfunction compute (target, name, getterOrAccessor, cache) {\n  ensure(target)\n  let getter, setter\n  if (isFunction(getterOrAccessor)) {\n    getter = cache !== false\n            ? makeComputed(target, getterOrAccessor)\n            : getterOrAccessor.bind(this)\n    setter = noop\n  } else {\n    getter = getterOrAccessor.get\n            ? getterOrAccessor.cache !== false || cache !== false\n              ? makeComputed(target, getterOrAccessor.get)\n              : getterOrAccessor.get.bind(this)\n            : noop\n    setter = getterOrAccessor.set ? getterOrAccessor.set.bind(this) : noop\n  }\n  defineAccessor(target, name, getter, setter)\n}\n\n/**\n * Watch property\n *\n * @param {Object} target\n * @param {String|Function} expressionOrFunction\n * @param {Function} callback\n * @param {Object} [options]\n *                 - {Boolean} deep\n *                 - {Boolean} sync\n *                 - {Boolean} lazy\n * @return {Watcher}\n */\n\nfunction watch (target, expressionOrFunction, callback, options = observe) {\n  ensure(target)\n  return doWatch(target, expressionOrFunction, callback, options)\n}\n\n/**\n * @param {Object} target\n */\n\nfunction init (target) {\n  defineValue(target, WATCHERS_PROPERTY_NAME, [], false)\n  defineValue(target, DATA_PROPTERTY_NAME, Object.create(null), false)\n  doObserve(target[DATA_PROPTERTY_NAME])\n  reactSelfProperties(target)\n}\n\nfunction ensure (target) {\n  if (!Object.prototype.hasOwnProperty.call(target, WATCHERS_PROPERTY_NAME)) {\n    init(target)\n  }\n}\n\n/**\n * @param {Object} target\n * @param {Object} methods\n */\n\nfunction carryMethods (target, methods) {\n  everyEntries(methods, (name, method) => {\n    target[name] = method.bind(target)\n  })\n}\n\n/**\n * @param {Object} target\n * @param {String} key\n * @param {*} value\n */\n\nfunction reactProperty (target, key, value) {\n  target[DATA_PROPTERTY_NAME][key] = value\n  defineReactive(target[DATA_PROPTERTY_NAME], key, value)\n  proxy(target, key)\n}\n\n/**\n * @param {Object} target\n * @param {Object} properties\n */\n\nfunction reactProperties (target, properties) {\n  everyEntries(properties, (key, value) => reactProperty(target, key, value))\n}\n\n/**\n * @param {Object} target\n */\n\nfunction reactSelfProperties (target) {\n  everyEntries(target, (key, value) => {\n    !isFunction(value) && reactProperty(target, key, value)\n  })\n}\n\n/**\n * @param {Object} target\n * @param {Object} properties\n */\n\nfunction computeProperties (target, properties) {\n  everyEntries(properties, (key, value) => compute(target, key, value))\n}\n\n/**\n * @param {Object} target\n * @param {Object} properties\n */\n\nfunction watchProperties (target, properties) {\n  everyEntries(properties, (expression, functionOrOption) => {\n    if (isFunction(functionOrOption)) {\n      watch(target, expression, functionOrOption)\n    } else {\n      watch(target, expression, functionOrOption.watcher, functionOrOption)\n    }\n  })\n}\n\n/**\n * @param {Object} target\n * @param {String} key\n */\n\nfunction proxy (target, key) {\n  function getter () {\n    return target[DATA_PROPTERTY_NAME][key]\n  }\n  function setter (value) {\n    target[DATA_PROPTERTY_NAME][key] = value\n  }\n  defineAccessor(target, key, getter, setter)\n}\n"],"names":["uid","Dep","id","subs","sub","push","$remove","target","addDep","i","l","length","update","OBSERVE_NAME","WATCHERS_PROPERTY_NAME","DATA_PROPTERTY_NAME","DEBUGGING","process","env","NODE_ENV","defineValue","object","property","value","enumerable","defineProperty","defineAccessor","getter","setter","isArray","Array","toString","Object","prototype","OBJECT_STRING","isPlainObject","call","isObject","isFunction","func","everyEntries","callback","keys","noop","warn","console","_Set","Set","match","set","create","has","key","undefined","add","clear","arrayPrototype","arrayMethods","arrayMutativeMethods","amend","array","setPrototypeOf","method","original","mutator","args","result","apply","observer","inserted","slice","observeArray","dep","notify","$set","index","Number","splice","item","indexOf","Observer","walk","convert","items","observe","hasOwnProperty","isExtensible","defineReactive","desc","getOwnPropertyDescriptor","configurable","get","childOb","reactiveGetter","currentValue","depend","e","reactiveSetter","newValue","oldValue","makeGetterFunction","body","Function","parse","expression","String","trim","callbacks","pending","nextTickHandler","callbackCopies","callNextTick","nextTick","MutationObserver","counter","textNode","document","createTextNode","data","setTimeout","context","arguments","unshift","queue","waiting","queueIndex","resetBatcherState","flushBatcherQueue","runBatcherQueue","watcher","run","batch","Watcher","owner","options","active","dirty","lazy","deps","newDeps","depIds","newDepIds","beforeGet","scope","deep","afterGet","addSub","removeSub","tmp","sync","current","traverse","watch","expressionOrFunction","parseExpression","makeComputed","computedGetter","evaluate","defineProperties","react","compute","writable","default","methods","carryMethods","reactProperties","computed","computeProperties","watchers","watchProperties","name","getterOrAccessor","cache","bind","doWatch","init","ensure","reactProperty","properties","reactSelfProperties","functionOrOption","proxy"],"mappings":"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"}